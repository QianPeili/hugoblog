<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Note on 爪子</title>
    <link>hugoblog/categories/note/</link>
    <description>Recent content in Note on 爪子</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sun, 03 Dec 2017 18:23:21 +0800</lastBuildDate>
    
	<atom:link href="hugoblog/categories/note/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Go的append使用踩坑记录</title>
      <link>hugoblog/posts/go%E7%9A%84append%E4%BD%BF%E7%94%A8%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/</link>
      <pubDate>Sun, 03 Dec 2017 18:23:21 +0800</pubDate>
      
      <guid>hugoblog/posts/go%E7%9A%84append%E4%BD%BF%E7%94%A8%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/</guid>
      <description>go 有个很好用的数据类型——slice，有点类似 python 里的 list。go 中给 slice 添加元素，用的是 append 函数，它跟python中的list.append方法有些不同，每次都会返回一个对象，所以我之前一直都把go中的append当做python中的 + 变形。
在我之前的理解中，某些情况下，两者其实是差不多的，比如：
go 代码
package main import &amp;quot;log&amp;quot; func main() { a := []int{1, 2} a = append(a, []int{3, 4}...) log.Println(a) }  python 代码
a = [1, 2] a = a + [3, 4] print(a)  输出结果 a 都是： [1, 2, 3, 4]，两者确实很相似
但是我今天在刷题目时，想要实现这么一个情况：
python 代码：
a = [1, 2, 3, 4, 5] b = a[:2] + a[3:]  执行后的结果： a == [1, 2, 3, 4, 5], b == [1, 2, 4, 5]</description>
    </item>
    
    <item>
      <title>Go跨平台编译</title>
      <link>hugoblog/posts/go%E8%B7%A8%E5%B9%B3%E5%8F%B0%E7%BC%96%E8%AF%91/</link>
      <pubDate>Wed, 01 Nov 2017 19:22:02 +0800</pubDate>
      
      <guid>hugoblog/posts/go%E8%B7%A8%E5%B9%B3%E5%8F%B0%E7%BC%96%E8%AF%91/</guid>
      <description>公司开发系统是 Windows，服务器部署环境是 Linux。一开始测试的时候选的是 git pull 带生产机上，编译后启动。
但这个方法太笨，一是代码容易泄露，二是生产机要同时同步库文件，不管是 go get 方式还是 govendor 方式都显得太麻烦。
不过好在 Go 的跨平台编译非常方便，所以我们完全可以在开发环境下编译好可执行文件，再放入生产机部署。
总结一下 windows环境下 go 跨平台编译的方式。
GOOS 和 GOARCH 关于这两个环境变量的含义，我们可以从官方文档： Installing Go from source - The Go Programming Language中了解，分别是目标系统的 操作系统 和 编译架构。只要我们设置好这两个参数的内容，就可以轻松进行跨平台编译了。
支持的列表
$GOOS $GOARCH android arm darwin 386 darwin amd64 darwin arm darwin arm64 dragonfly amd64 freebsd 386 freebsd amd64 freebsd arm linux 386 linux amd64 linux arm linux arm64 linux ppc64 linux ppc64le linux mips linux mipsle linux mips64 linux mips64le netbsd 386 netbsd amd64 netbsd arm openbsd 386 openbsd amd64 openbsd arm plan9 386 plan9 amd64 solaris amd64 windows 386 windows amd64  Windows cmd 最直接的了，需要修改环境变量</description>
    </item>
    
    <item>
      <title>Go 的request.Body rewind 功能</title>
      <link>hugoblog/posts/request-body%E7%9A%84rewind%E5%8A%9F%E8%83%BD/</link>
      <pubDate>Sat, 16 Sep 2017 18:31:52 +0800</pubDate>
      
      <guid>hugoblog/posts/request-body%E7%9A%84rewind%E5%8A%9F%E8%83%BD/</guid>
      <description>近日参加了实验楼的 楼赛 第15期 Go语言项目挑战 - 实验楼
第一道题的题目要求是：
 实现一个简单的数据校验功能，对请求 body 做 md5 计算，然后把结果转为十六进制添加到请求 header 中，头部名称为X-Md5。也就是在HTTP 请求 header 中添加一个 X-Md5: 键值对，如果body为空那么就不填。
 我一开始的实现方式很直接暴力：
func (t *Transport) RoundTrip(req *http.Request) (*http.Response, error) { if req.Body == nil { return t.RoundTripper.RoundTrip(req) } b, err := ioutil.ReadAll(req.Body) if len(b) == 0 { return t.RoundTripper.RoundTrip(req) } if err != nil { log.Fatal(err.Error()) } hexB := md5.Sum(b) req.Header.Add(&amp;quot;X-Md5&amp;quot;, hex.EncodeToString(hexB[:])) return t.RoundTripper.RoundTrip(req) }  直接读出 req.Body 中的字节数据，进行md5运算。我在自己的电脑上测试通过，但是实验环境下 go test 会报类似错误：</description>
    </item>
    
    <item>
      <title>升级 GCC 来解决 heapdump build Error</title>
      <link>hugoblog/posts/%E5%8D%87%E7%BA%A7gcc%E8%A7%A3%E5%86%B3heapdump%E5%AE%89%E8%A3%85%E9%94%99%E8%AF%AF/</link>
      <pubDate>Wed, 16 Aug 2017 21:10:24 +0800</pubDate>
      
      <guid>hugoblog/posts/%E5%8D%87%E7%BA%A7gcc%E8%A7%A3%E5%86%B3heapdump%E5%AE%89%E8%A3%85%E9%94%99%E8%AF%AF/</guid>
      <description>今天要部署一个node.js的项目，第一次玩node.js有点崩溃。安装依赖的时候一个heapdump库出现了build error。
在github上找到了类似的issue： [error] heapdump@0.3.7 Build Error · Issue #72 · bnoordhuis/node-heapdump
里面提到的解决方式是升级GCC：
 Well, I have fixed it!
My gcc version is 4.6.3 when I update to 4.9.1 and retry it work!
 我查看了一下机器的gcc版本，是 4.4.7 的，问题应该就在这了。所以安装一个新版本的gcc应该就行了。
国内为了速度可以选择中科院的镜像： Index of /gnu/gcc/
我选择了 6.1.0 版本，下载源码后简单地根据官方教程 InstallingGCC - GCC Wiki 进行安装。
tar xzf gcc-6.1.0.tar.gz cd gcc-6.1.0 ./contrib/download_prerequisites cd .. mkdir objdir cd objdir $PWD/../gcc-6.1.0/configure --prefix=$HOME/gcc-6.1.0 --disable-multilib  因为gcc编译真的要好久好久，所以我用上了全部 cpu 核心。
make -j 16 make -j 16 install  替换旧版的gcc</description>
    </item>
    
    <item>
      <title>Bash输出重定向</title>
      <link>hugoblog/posts/%E8%BE%93%E5%87%BA%E9%87%8D%E5%AE%9A%E5%90%91/</link>
      <pubDate>Sun, 09 Jul 2017 15:20:36 +0800</pubDate>
      
      <guid>hugoblog/posts/%E8%BE%93%E5%87%BA%E9%87%8D%E5%AE%9A%E5%90%91/</guid>
      <description>对 bash 命令一直不太熟，每次使用 nohup 命令都要从网上现找。 有时会看到一些命令后面跟着 &amp;quot;2&amp;gt;&amp;amp;1&amp;quot; 的参数。比如
nohupy python test.py &amp;gt; test.log 2&amp;gt;&amp;amp;1  之前也没有多管，直接用了。前几天又在其他人的 shell 脚本中看到 &amp;quot;2&amp;gt;&amp;amp;1&amp;quot;, 才想起去了解一下 ，现把内容整理一下做记录。
主要内容借鉴于Bash One-Liners Explained, Part III: All about redirections - good coders code, great coders reuse，原文非常详细，欢迎访问原文。
当 bash 启动时，会开启三个标准文件描述符：stdin, stdout, stderr。
它们都指向了 /dev/tty0 即我们当前使用的控制台。 0 代表 stdin， 1 代表 stdout, 2 代表stderr。
当我们输入一个命令：
python test.py &amp;gt; file  &amp;gt; 就是输出重定向运算符，bash 首先会以写的形式打开 file，成功后上述命令的 stdout 就会被发送到这个打开的 file 中。如果打开失败，则整个命令失败。
python test.py &amp;gt; file 命令等同于 python test.</description>
    </item>
    
    <item>
      <title>Git Submodule的使用</title>
      <link>hugoblog/posts/git-submodule%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Tue, 13 Jun 2017 19:11:01 +0800</pubDate>
      
      <guid>hugoblog/posts/git-submodule%E4%BD%BF%E7%94%A8/</guid>
      <description>Submodule介绍 前几天因为项目需求，接触了Git的Submodule功能。
客户端和服务端的项目各自独立开发，因为要用到一个共同的子库——SubA，SubA即需要独立保持版本信息，又需要同时给客户端和服务端的项目提供支持。Submodule正好可以帮助我们管理这个问题。
Submodule语法 git submodule [--quiet] add [&amp;lt;options&amp;gt;] [--] &amp;lt;repository[&amp;lt;path&amp;gt;] git submodule [--quiet] status [--cached] [--recursive] [--] [&amp;lt;path&amp;gt;…​] git submodule [--quiet] init [--] [&amp;lt;path&amp;gt;…​] git submodule [--quiet] deinit [-f|--force] (--all|[--] &amp;lt;path&amp;gt;…​) git submodule [--quiet] update [&amp;lt;options&amp;gt;] [--] [&amp;lt;path&amp;gt;…​] git submodule [--quiet] summary [&amp;lt;options&amp;gt;] [--] [&amp;lt;path&amp;gt;…​] git submodule [--quiet] foreach [--recursive] &amp;lt;command&amp;gt; git submodule [--quiet] sync [--recursive] [--] [&amp;lt;path&amp;gt;…​] git submodule [--quiet] absorbgitdirs [--] [&amp;lt;path&amp;gt;…​]  Submodule实践 目前有3个库： Main， SubA, SubB</description>
    </item>
    
    <item>
      <title>Go的依赖管理工具govendor</title>
      <link>hugoblog/posts/go%E7%9A%84%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7govendor/</link>
      <pubDate>Mon, 22 May 2017 18:11:05 +0800</pubDate>
      
      <guid>hugoblog/posts/go%E7%9A%84%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7govendor/</guid>
      <description>依赖管理是我接触 go 以来，觉得比较麻烦的事情。 不过在 go-1.5 版本中，出现了一个 vendor 的概念，并且 vendor 作为一个默认功能存在于1.7之后的版本中。
vendor的概念就类似于python中的 virtualenv 建立的 env，它是一个文件夹，里面存放了项目所用的依赖。如果项目中有个文件 import 了第三方的 package，而这个 package 又存在项目的 vendor 目录中，这个文件编译的时候会从 vendor 中 import 这个 package
比如：
$GOPATH | src/ | | project/ | | | main.go | | | vendor/ | | | | github.com/pkg/sftp/ | | | | golang.org/x/crypto/ssh/ | | | | | agent/  其中 project/main.go 中:
import ( ... &amp;quot;golang.org/x/crypto/ssh&amp;quot; )  因为项目 project 中有 vendor 目录，并且存在 golang.</description>
    </item>
    
    <item>
      <title>tcp经受时延</title>
      <link>hugoblog/posts/tcp%E7%BB%8F%E5%8F%97%E6%97%B6%E5%BB%B6/</link>
      <pubDate>Sat, 20 May 2017 16:15:51 +0800</pubDate>
      
      <guid>hugoblog/posts/tcp%E7%BB%8F%E5%8F%97%E6%97%B6%E5%BB%B6/</guid>
      <description>学 TCP/IP 协议听到最多的就是三次握手和四次挥手协议了吧。由于最近在折腾 tcpdump ，就想着实战抓一下 tcp 协议的这个握手和挥手协议。于是我在本地向内网测试机器的服务上发起了一个 POST 请求，抓到如下信息：
15:05:03.904647 IP socket-client.56558 &amp;gt; socket-server.3000: Flags [S], seq 2090421259, win 64240, options [mss 1460,nop,wscale 8,nop,nop,sackOK], length 0 15:05:03.904699 IP socket-server.3000 &amp;gt; socket-client.56558: Flags [S.], seq 2303886283, ack 2090421260, win 29200, options [mss 1460,nop,nop,sackOK,nop,wscale 7], length 0 15:05:03.905263 IP socket-client.56558 &amp;gt; socket-server.3000: Flags [.], ack 1, win 2053, length 0 15:05:03.905596 IP socket-client.56558 &amp;gt; socket-server.3000: Flags [P.], seq 1:230, ack 1, win 2053, length 229 15:05:03.</description>
    </item>
    
    <item>
      <title>tcpdump的使用实例</title>
      <link>hugoblog/posts/tcpdump%E7%9A%84%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B/</link>
      <pubDate>Sat, 20 May 2017 13:46:45 +0800</pubDate>
      
      <guid>hugoblog/posts/tcpdump%E7%9A%84%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B/</guid>
      <description>介绍 tcpdump 是 Linux 系统下进行网络分析的重要工具，我也因为对抓包这一块有些好奇，就找了些资料学习，然后整理成这篇文章。
使用说明 命令模式：
tcpdump [ -AbdDefhHIJKlLnNOpqStuUvxX# ] [ -B buffer_size ] [ -c count ] [ -C file_size ] [ -G rotate_seconds ] [ -F file ] [ -i interface ] [ -j tstamp_type ] [ -m module ] [ -M secret ] [ --number ] [ -Q in|out|inout ] [ -r file ] [ -V file ] [ -s snaplen ] [ -T type ] [ -w file ] [ -W filecount ] [ -E spi@ipaddr algo:secret,.</description>
    </item>
    
  </channel>
</rss>